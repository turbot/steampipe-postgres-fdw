// Generated by cgo from fdw.go. Included here so our functions are
// defined and available.
#include "steampipe_postgres_fdw.h"
#include "fdw_handlers.h"
#include "nodes/plannodes.h"
#include "access/xact.h"

extern PGDLLEXPORT void _PG_init(void);

static int deparseLimit(PlannerInfo *root);
static char *datumToString(Datum datum, Oid type);
static char *convertUUID(char *uuid);

static void pgfdw_xact_callback(XactEvent event, void *arg);
static void exitHook(int code, Datum arg);

//static void add_foreign_ordered_paths(PlannerInfo *root, RelOptInfo *input_rel,
//						  RelOptInfo *ordered_rel);
//static void estimate_path_cost_size(double *p_rows, int *p_width,
//                                    Cost *p_startup_cost, Cost *p_total_cost,
//									double coef);

void *serializePlanState(FdwPlanState *state);
FdwExecState *initializeExecState(void *internalstate);
// Required by postgres, doing basic checks to ensure compatibility,
// such as being compiled against the correct major version.
PG_MODULE_MAGIC;

/*
 * _PG_init
 * 		Library load-time initalization.
 * 		Sets exitHook() callback for backend shutdown.
 */
void _PG_init(void)
{
  /* register an exit hook */
  on_proc_exit(&exitHook, PointerGetDatum(NULL));
  RegisterXactCallback(pgfdw_xact_callback, NULL);
}

/*
 * pgfdw_xact_callback gets called when a running
 * query is cancelled
 */
static void
pgfdw_xact_callback(XactEvent event, void *arg)
{
  if (event == XACT_EVENT_ABORT)
  {
    goFdwAbortCallback();
  }
}

/*
 * exitHook
 * 		Close all Oracle connections on process exit.
 */

void exitHook(int code, Datum arg)
{
  goFdwShutdown();
}

static bool fdwIsForeignScanParallelSafe(PlannerInfo *root, RelOptInfo *rel, RangeTblEntry *rte) {
	return getenv("STEAMPIPE_FDW_PARALLEL_SAFE") != NULL;
}

static void fdwGetForeignRelSize(PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid)
{
  // initialise logging`
  // to set the log level for fdw logging from C code, set log_min_messages in postgresql.conf
  goInit();

  FdwPlanState *planstate = palloc0(sizeof(FdwPlanState));
  ForeignTable *ftable = GetForeignTable(foreigntableid);

  ListCell *lc;
  bool needWholeRow = false;
  TupleDesc desc;

  // Save plan state information
  baserel->fdw_private = planstate;
  planstate->foreigntableid = foreigntableid;

  // Initialize the conversion info array
  {
    Relation rel = RelationIdGetRelation(ftable->relid);
    AttInMetadata *attinmeta;
    desc = RelationGetDescr(rel);
    attinmeta = TupleDescGetAttInMetadata(desc);
    planstate->numattrs = RelationGetNumberOfAttributes(rel);
    planstate->cinfos = palloc0(sizeof(ConversionInfo *) * planstate->numattrs);
    initConversioninfo(planstate->cinfos, attinmeta);
    needWholeRow = rel->trigdesc && rel->trigdesc->trig_insert_after_row;
    RelationClose(rel);
  }

  // Gather the target_list of columns for this query as Value objects.
  if (needWholeRow)
  {
    int i;
    for (i = 0; i < desc->natts; i++)
    {
      Form_pg_attribute att = TupleDescAttr(desc, i);
      if (!att->attisdropped)
      {
        planstate->target_list = lappend(planstate->target_list, makeString(NameStr(att->attname)));
      }
    }
  }
  else
  {
    foreach (lc, extractColumns(baserel->reltarget->exprs, baserel->baserestrictinfo))
    {
      Var *var = (Var *)lfirst(lc);
#if PG_VERSION_NUM >= 150000
      String *colname;
#else
      Value *colname;
#endif
      // Store only a Value node containing the string name of the column.
      colname = colnameFromVar(var, root, planstate);
      if (colname != NULL && strVal(colname) != NULL)
      {
        planstate->target_list = lappend(planstate->target_list, colname);
      }
    }
  }

  // Deduce the limit, if one was specified
  planstate->limit = deparseLimit(root);

  // Inject the "rows" and "width" attribute into the baserel
  goFdwGetRelSize(planstate, root, &baserel->rows, &baserel->reltarget->width, baserel);

  planstate->width = baserel->reltarget->width;
}

/*
 * deparseLimit
 * 		Deparse LIMIT clause to extract the limit count (limit+offset)
 */
static int deparseLimit(PlannerInfo *root)
{
  int limitVal = 0, offsetVal = 0;

  /* don't push down LIMIT if the query has a GROUP BY, DISTINCT, ORDER BY clause or aggregates
     or if the query refers to more than 1 table */
  if (root->parse->groupClause != NULL ||
      root->parse->sortClause != NULL ||
      root->parse->distinctClause != NULL ||
      root->parse->hasAggs ||
      root->parse->hasDistinctOn ||
      bms_num_members(root->all_baserels) != 1)
    return -1;

  /* only push down constant LIMITs that are not NULL */
  if (root->parse->limitCount != NULL && IsA(root->parse->limitCount, Const))
  {
    Const *limit = (Const *)root->parse->limitCount;
    if (limit->constisnull)
      return -1;
    limitVal = atoi(datumToString(limit->constvalue, limit->consttype));
  }
  else
  {
    return -1;
  }

  /* only consider OFFSETS that are non-NULL constants */
  if (root->parse->limitOffset != NULL && IsA(root->parse->limitOffset, Const))
  {
    Const *offset = (Const *)root->parse->limitOffset;
    if (!offset->constisnull)
      offsetVal = atoi(datumToString(offset->constvalue, offset->consttype));
  }

  return limitVal + offsetVal;
}

/*
 * fdwGetForeignPaths
 *		Create possible access paths for a scan on the foreign table.
 *		This is done by calling the "get_path_keys method on the python side,
 *		and parsing its result to build parameterized paths according to the
 *		equivalence classes found in the plan.
 */
static void fdwGetForeignPaths(PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid)
{
   elog(INFO, "fdwGetForeignPaths");
   goLog("fdwGetForeignPaths");

  List *paths; /* List of ForeignPath */
  FdwPlanState *planstate = baserel->fdw_private;
  ListCell *lc;
  /* These lists are used to handle sort pushdown */
  List *apply_pathkeys = NULL;
  List *deparsed_pathkeys = NULL;

  /* Extract a friendly version of the pathkeys. */
  List *possiblePaths = goFdwGetPathKeys(planstate);

  /* Try to find parameterized paths */
  paths = findPaths(root, baserel, possiblePaths, planstate->startupCost, planstate, apply_pathkeys, deparsed_pathkeys);

  /* Add a simple default path */
  paths = lappend(paths, create_foreignscan_path(
                             root,
                             baserel,
                             NULL, /* default pathtarget */
                             baserel->rows,
                             planstate->startupCost,
                             baserel->rows * baserel->reltarget->width * 100000, // table scan is very expensive
                             NIL,                                                /* no pathkeys */
                             NULL,
                             NULL,
                             NULL));

  /* Handle sort pushdown */
  if (root->query_pathkeys)
  {
    List *deparsed = deparse_sortgroup(root, foreigntableid, baserel);
    if (deparsed)
    {
      /* Update the sort_*_pathkeys lists if needed */
      computeDeparsedSortGroup(deparsed, planstate, &apply_pathkeys, &deparsed_pathkeys);
    }
  }

  /* Add each ForeignPath previously found */
  foreach (lc, paths)
  {
    ForeignPath *path = (ForeignPath *)lfirst(lc);
    /* Add the path without modification */
    add_path(baserel, (Path *)path);
    /* Add the path with sort pushdown if possible */
    if (apply_pathkeys && deparsed_pathkeys)
    {
      ForeignPath *newpath;
      newpath = create_foreignscan_path(
          root,
          baserel,
          NULL, /* default pathtarget */
          path->path.rows,
          path->path.startup_cost, path->path.total_cost,
          apply_pathkeys, NULL,
          NULL,
          (void *)deparsed_pathkeys);
      newpath->path.param_info = path->path.param_info;
      add_path(baserel, (Path *)newpath);
    }
  }
}

/*
 * fdwGetForeignPlan
 *		Create a ForeignScan plan node for scanning the foreign table
 */
static ForeignScan *fdwGetForeignPlan(
    PlannerInfo *root,
    RelOptInfo *baserel,
    Oid foreigntableid,
    ForeignPath *best_path,
    List *tlist,
    List *scan_clauses,
    Plan *outer_plan)
{
  Index scan_relid = baserel->relid;
  FdwPlanState *planstate = (FdwPlanState *)baserel->fdw_private;
  best_path->path.pathtarget->width = planstate->width;
  scan_clauses = extract_actual_clauses(scan_clauses, false);

  planstate->pathkeys = (List *)best_path->fdw_private;
  ForeignScan *s = make_foreignscan(
      tlist,
      scan_clauses,
      scan_relid,
      scan_clauses, /* no expressions to evaluate */
      serializePlanState(planstate),
      NULL,
      NULL, /* All quals are meant to be rechecked */
      NULL);
  return s;
}

/*
 *	"Serialize" a FdwPlanState, so that it is safe to be carried
 *	between the plan and the execution safe.
 */
void *serializePlanState(FdwPlanState *state)
{
  List *result = NULL;
  result = lappend(result, makeConst(INT4OID, -1, InvalidOid, 4, Int32GetDatum(state->numattrs), false, true));
  result = lappend(result, state->target_list);
  result = lappend(result, serializeDeparsedSortGroup(state->pathkeys));
  result = lappend(result, makeConst(INT4OID, -1, InvalidOid, 4, Int32GetDatum(state->limit), false, true));

  return result;
}

/*
 *	"Deserialize" an internal state and inject it in an
 *	FdwExecState
 */
FdwExecState *initializeExecState(void *internalstate)
{
  FdwExecState *execstate = palloc0(sizeof(FdwExecState));
  // internalstate is actually a list generated by serializePlanState consisting of:
  //  numattrs, target_list, target_list, pathkeys
  List *values = (List *)internalstate;
  AttrNumber numattrs = ((Const *)linitial(values))->constvalue;
  List *pathkeys;
  int limit;
  /* Those list must be copied, because their memory context can become */
  /* invalid during the execution (in particular with the cursor interface) */
  execstate->target_list = copyObject(lsecond(values));
  pathkeys = lthird(values);
  limit = ((Const *)lfourth(values))->constvalue;

  execstate->pathkeys = deserializeDeparsedSortGroup(pathkeys);
  execstate->buffer = makeStringInfo();
  execstate->cinfos = palloc0(sizeof(ConversionInfo *) * numattrs);
  execstate->numattrs = numattrs;
  execstate->values = palloc(numattrs * sizeof(Datum));
  execstate->nulls = palloc(numattrs * sizeof(bool));
  execstate->limit = limit;
  return execstate;
}

/*
 * datumToString
 * 		Convert a Datum to a string by calling the type output function.
 * 		Returns the result or NULL if it cannot be converted.
 */
static char *datumToString(Datum datum, Oid type)
{
  StringInfoData result;
  regproc typoutput;
  HeapTuple tuple;
  char *str, *p;

  /* get the type's output function */
  tuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));
  if (!HeapTupleIsValid(tuple))
  {
    elog(ERROR, "cache lookup failed for type %u", type);
  }
  typoutput = ((Form_pg_type)GETSTRUCT(tuple))->typoutput;
  ReleaseSysCache(tuple);

  switch (type)
  {
  case TEXTOID:
  case CHAROID:
  case BPCHAROID:
  case VARCHAROID:
  case NAMEOID:
  case UUIDOID:
    str = DatumGetCString(OidFunctionCall1(typoutput, datum));

    if (str[0] == '\0')
      return NULL;

    /* strip "-" from "uuid" values */
    if (type == UUIDOID)
      convertUUID(str);

    /* quote string */
    initStringInfo(&result);
    appendStringInfo(&result, "'");
    for (p = str; *p; ++p)
    {
      if (*p == '\'')
        appendStringInfo(&result, "'");
      appendStringInfo(&result, "%c", *p);
    }
    appendStringInfo(&result, "'");
    break;
  case INT8OID:
  case INT2OID:
  case INT4OID:
  case OIDOID:
  case FLOAT4OID:
  case FLOAT8OID:
  case NUMERICOID:
    str = DatumGetCString(OidFunctionCall1(typoutput, datum));
    initStringInfo(&result);
    appendStringInfo(&result, "%s", str);
    break;
    //        case DATEOID:
    //			str = deparseDate(datum);
    //			initStringInfo(&result);
    //			appendStringInfo(&result, "(CAST ('%s' AS DATE))", str);
    //			break;
    //		case TIMESTAMPOID:
    //			str = deparseTimestamp(datum, false);
    //			initStringInfo(&result);
    //			appendStringInfo(&result, "(CAST ('%s' AS TIMESTAMP))", str);
    //			break;
    //		case TIMESTAMPTZOID:
    //			str = deparseTimestamp(datum, true);
    //			initStringInfo(&result);
    //			appendStringInfo(&result, "(CAST ('%s' AS TIMESTAMP WITH TIME ZONE))", str);
    //			break;
    //		case INTERVALOID:
    //			str = deparseInterval(datum);
    //			if (str == NULL)
    //				return NULL;
    //			initStringInfo(&result);
    //			appendStringInfo(&result, "%s", str);
    //			break;
  default:
    return NULL;
  }

  return result.data;
}
/*
 * convertUUID
 * 		Strip "-" from a PostgreSQL "uuid" so that Oracle can parse it.
 * 		In addition, convert the string to upper case.
 * 		This modifies the argument in place!
 */
char *convertUUID(char *uuid)
{
  char *p = uuid, *q = uuid, c;

  while (*p != '\0')
  {
    if (*p == '-')
      ++p;
    c = *(p++);
    if (c >= 'a' && c <= 'f')
      *(q++) = c - ('a' - 'A');
    else
      *(q++) = c;
  }
  *q = '\0';

  return uuid;
}

//
///*
// * fdwGetForeignUpperPaths
// *		Add paths for post-join operations like aggregation, grouping etc. if
// *		corresponding operations are safe to push down.
// *
// * Right now, we only support aggregate, grouping and having clause pushdown.
// */
//static void
//fdwGetForeignUpperPaths(PlannerInfo *root, UpperRelationKind stage,
//                               RelOptInfo *input_rel, RelOptInfo *output_rel,
//                               void *extra)
//{
//
//	if  (stage != UPPERREL_ORDERED  ||
//		output_rel->fdw_private)
//		return;
//
//    goLog("fdwGetForeignUpperPaths");
//
//
////	/*
////	 * If input rel is not safe to pushdown, then simply return as we cannot
////	 * perform any post-join operations on the foreign server.
////	 */
////	if (!input_rel->fdw_private){
////	        goLog("!input_rel->fdw_private");
////	        return;
////    }
//
//
////  if (!((FdwPlanState *) input_rel->fdw_private)->pushdown_safe){
////      goLog("!pushdown_safe");
////      return;
////   }
//
//
//    FdwPlanState *planstate = palloc0(sizeof(FdwPlanState));
//
//    // NEEDED??
//    planstate->pushdown_safe = false;
//
//    // Save plan state information
//    output_rel->fdw_private = planstate;
//
////	struct timeval time1,time2;
////
////	gettimeofday(&time1, NULL);
//
//
//
//    add_foreign_ordered_paths(root, input_rel, output_rel);
//
//}
//
//
///* Struct for extra information passed to estimate_path_cost_size() */
//typedef struct
//{
//	PathTarget *target;
//	bool		has_final_sort;
//	bool		has_limit;
//	double		limit_tuples;
//	int64		count_est;
//	int64		offset_est;
//} PgFdwPathExtraData;
//
//
///*
// * add_foreign_ordered_paths
// *		Add foreign paths for performing the final sort remotely.
// *
// * Given input_rel contains the source-data Paths.  The paths are added to the
// * given ordered_rel.
// */
//static void
//add_foreign_ordered_paths(PlannerInfo *root, RelOptInfo *input_rel,
//						  RelOptInfo *ordered_rel)
//{
//    goLog("add_foreign_ordered_paths");
//    Query	   *parse = root->parse;
////   	PgFdwRelationInfo *ifpinfo = input_rel->fdw_private;
////   	PgFdwRelationInfo *fpinfo = ordered_rel->fdw_private;
//   	PgFdwPathExtraData *fpextra;
//   	double		rows;
//   	int			width;
//   	Cost		startup_cost;
//   	Cost		total_cost;
//   	List	   *fdw_private;
//   	ForeignPath *ordered_path;
//   	ListCell   *lc;
//
//   	/* Shouldn't get here unless the query has ORDER BY */
//   	Assert(parse->sortClause);
//
//   	/* We don't support cases where there are any SRFs in the targetlist */
//   	if (parse->hasTargetSRFs){
//   	    goLog("hasTargetSRFs");
//   		return;
//    }
//
//   	/* Save the input_rel as outerrel in fpinfo */
////   	fpinfo->outerrel = input_rel;
//
//   	/*
//   	 * Copy foreign table, foreign server, user mapping, FDW options etc.
//   	 * details from the input relation's fpinfo.
//   	 */
////   	fpinfo->table = ifpinfo->table;
////   	fpinfo->server = ifpinfo->server;
////   	fpinfo->user = ifpinfo->user;
////   	merge_fdw_options(fpinfo, ifpinfo, NULL);
//
//   	/*
//   	 * If the input_rel is a base or join relation, we would already have
//   	 * considered pushing down the final sort to the remote server when
//   	 * creating pre-sorted foreign paths for that relation, because the
//   	 * query_pathkeys is set to the root->sort_pathkeys in that case (see
//   	 * standard_qp_callback()).
//   	 */
//   	if (input_rel->reloptkind == RELOPT_BASEREL)
////   	||
////   		input_rel->reloptkind == RELOPT_JOINREL)
//   	{
//   	    goLog("reloptkind == RELOPT_BASEREL ");
//
//   		Assert(root->query_pathkeys == root->sort_pathkeys);
//
//   		/* Safe to push down if the query_pathkeys is safe to push down */
////   		fpinfo->pushdown_safe = ifpinfo->qp_is_pushdown_safe;
//
//   		return;
//   	}
//
//   	/* The input_rel should be a grouping relation */
////   	Assert(input_rel->reloptkind == RELOPT_UPPER_REL &&
////   		   ifpinfo->stage == UPPERREL_GROUP_AGG);
//
//   	/*
//   	 * We try to create a path below by extending a simple foreign path for
//   	 * the underlying grouping relation to perform the final sort remotely,
//   	 * which is stored into the fdw_private list of the resulting path.
//   	 */
//
//   	/* Assess if it is safe to push down the final sort */
//   	foreach(lc, root->sort_pathkeys)
//   	{
//   	    goLog("sort pathkeys");
//   		PathKey    *pathkey = (PathKey *) lfirst(lc);
//   		EquivalenceClass *pathkey_ec = pathkey->pk_eclass;
//
//   		/*
//   		 * is_foreign_expr would detect volatile expressions as well, but
//   		 * checking ec_has_volatile here saves some cycles.
//   		 */
//   		if (pathkey_ec->ec_has_volatile)
//   			return;
//
//   		/*
//   		 * Can't push down the sort if pathkey's opfamily is not shippable.
//   		 */
////   		if (!is_shippable(pathkey->pk_opfamily, OperatorFamilyRelationId,
////   						  fpinfo))
////   			return;
//
//   		/*
//   		 * The EC must contain a shippable EM that is computed in input_rel's
//   		 * reltarget, else we can't push down the sort.
//   		 */
////   		if (find_em_for_rel_target(root,
////   								   pathkey_ec,
////   								   input_rel) == NULL)
////   			return;
//   	}
//
//   	/* Safe to push down */
////   	fpinfo->pushdown_safe = true;
//
//   	/* Construct PgFdwPathExtraData */
//   	fpextra = (PgFdwPathExtraData *) palloc0(sizeof(PgFdwPathExtraData));
//   	fpextra->target = root->upper_targets[UPPERREL_ORDERED];
//   	fpextra->has_final_sort = true;
//
//   	/* Estimate the costs of performing the final sort remotely */
//   	estimate_path_cost_size(&rows, &width, &startup_cost, &total_cost, 0.1);
//
//  	 /* Build the fdw_private list that will be used by postgresGetForeignPlan.
//  	 * Items in the list must match order in enum FdwPathPrivateIndex.
//  	 */
//  	fdw_private = list_make2(makeInteger(true), makeInteger(false));
//
//  	/* Create foreign ordering path */
//  	ordered_path = create_foreign_upper_path(root,
//  											 input_rel,
//  											 root->upper_targets[UPPERREL_ORDERED],
//  											 rows,
//  											 startup_cost,
//  											 total_cost,
//  											 root->sort_pathkeys,
//  											 NULL,	/* no extra plan */
//  											 fdw_private);
//   	/* and add it to the ordered_rel */
//   	add_path(ordered_rel, (Path *) ordered_path);
//}
//
//
///*
// * estimate_path_cost_size
// *		Get cost and size estimates for a foreign scan on given foreign relation
// *		either a base relation or a join between foreign relations or an upper
// *		relation containing foreign relations.
// *
// * param_join_conds are the parameterization clauses with outer relations.
// * pathkeys specify the expected sort order if any for given path being costed.
// *
// * The function returns the cost and size estimates in p_row, p_width,
// * p_startup_cost and p_total_cost variables.
// */
//static void
//estimate_path_cost_size(double *p_rows, int *p_width,
//                        Cost *p_startup_cost, Cost *p_total_cost, double coef)
//{
//	*p_rows = 1;
//	*p_width = 1;
//	*p_startup_cost = 1.0;
//	*p_total_cost = -1 + coef;
//}