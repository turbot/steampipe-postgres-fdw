// Generated by cgo from fdw.go. Included here so our functions are
// defined and available.
#include "steampipe_postgres_fdw.h"
#include "fdw_handlers.h"
#include "nodes/plannodes.h"
#include "access/xact.h"

extern PGDLLEXPORT void _PG_init(void);

static int deparseLimit(PlannerInfo *root);
static char *datumToString(Datum datum, Oid type);
static char *convertUUID(char *uuid);

static void pgfdw_xact_callback(XactEvent event, void *arg);
static void exitHook(int code, Datum arg);

void *serializePlanState(FdwPlanState *state);
FdwExecState *initializeExecState(void *internalstate);
// Required by postgres, doing basic checks to ensure compatibility,
// such as being compiled against the correct major version.
PG_MODULE_MAGIC;

// Define the handler function for signal 16
void signal_handler(int sig) {
//    elog(NOTICE, "Caught signal %d", sig);
}

/*
 * _PG_init
 * 		Library load-time initalization.
 * 		Sets exitHook() callback for backend shutdown.
 */
void _PG_init(void)
{
    // TACTICAL
    // certain postgres errors (`out of shared memory`, `schema already exists`)
    // sometimes in a signal 16 being sent from the C code
    // this sometimes causes a crash as the signal handler is not set up correctly for Go (SA_ONSTACK is not set)
    // To avoid this, handle the signal directly and swallow it

    struct sigaction sa;

    // Clear the sigaction structure
    memset(&sa, 0, sizeof(sa));

    // Set the pointer to the handler function
    sa.sa_handler = signal_handler;

    // Set the SA_ONSTACK flag to ensure the handler runs on a separate stack
    sa.sa_flags = SA_ONSTACK;

    // Block other signals while handling
    sigfillset(&sa.sa_mask);

    // Register the signal handler for signal 16
    if (sigaction(16, &sa, NULL) == -1) {
        perror("Failed to set signal handler");
        exit(EXIT_FAILURE);
    }


  /* register an exit hook */
  on_proc_exit(&exitHook, PointerGetDatum(NULL));
  RegisterXactCallback(pgfdw_xact_callback, NULL);

}

/*
 * pgfdw_xact_callback gets called when a running
 * query is cancelled
 */
static void
pgfdw_xact_callback(XactEvent event, void *arg)
{
  if (event == XACT_EVENT_ABORT)
  {
    goFdwAbortCallback();
  }
}

/*
 * exitHook
 * 		Close all Oracle connections on process exit.
 */

void exitHook(int code, Datum arg)
{
  goFdwShutdown();
}

static bool fdwIsForeignScanParallelSafe(PlannerInfo *root, RelOptInfo *rel, RangeTblEntry *rte) {
	return getenv("STEAMPIPE_FDW_PARALLEL_SAFE") != NULL;
}

static void fdwGetForeignRelSize(PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid)
{
  FdwPlanState *planstate;
  ForeignTable *ftable;
  ListCell *lc;
  TupleDesc desc;
  bool needWholeRow = false;

  // initialise logging`
  // to set the log level for fdw logging from C code, set log_min_messages in postgresql.conf
  goInit();

  planstate = palloc0(sizeof(FdwPlanState));
  ftable = GetForeignTable(foreigntableid);


  // Save plan state information
  baserel->fdw_private = planstate;
  planstate->foreigntableid = foreigntableid;

  // Initialize the conversion info array
  {
    Relation rel = RelationIdGetRelation(ftable->relid);
    AttInMetadata *attinmeta;
    desc = RelationGetDescr(rel);
    attinmeta = TupleDescGetAttInMetadata(desc);
    planstate->numattrs = RelationGetNumberOfAttributes(rel);
    planstate->cinfos = palloc0(sizeof(ConversionInfo *) * planstate->numattrs);
    initConversioninfo(planstate->cinfos, attinmeta);
    needWholeRow = rel->trigdesc && rel->trigdesc->trig_insert_after_row;
    RelationClose(rel);
  }

  // Gather the target_list of columns for this query as Value objects.
  if (needWholeRow)
  {
    int i;
    for (i = 0; i < desc->natts; i++)
    {
      Form_pg_attribute att = TupleDescAttr(desc, i);
      if (!att->attisdropped)
      {
        planstate->target_list = lappend(planstate->target_list, makeString(NameStr(att->attname)));
      }
    }
  }
  else
  {
    foreach (lc, extractColumns(baserel->reltarget->exprs, baserel->baserestrictinfo))
    {
      Var *var = (Var *)lfirst(lc);
#if PG_VERSION_NUM >= 150000
      String *colname;
#else
      Value *colname;
#endif
      // Store only a Value node containing the string name of the column.
      colname = colnameFromVar(var, root, planstate);
      if (colname != NULL && strVal(colname) != NULL)
      {
        planstate->target_list = lappend(planstate->target_list, colname);
      }
    }
  }

  // Deduce the limit, if one was specified
  planstate->limit = deparseLimit(root);

  // Inject the "rows" and "width" attribute into the baserel
  goFdwGetRelSize(planstate, root, &baserel->rows, &baserel->reltarget->width, baserel);

  planstate->width = baserel->reltarget->width;
}

/*
 * deparseLimit
 * 		Deparse LIMIT clause to extract the limit count (limit+offset)
 */
static int deparseLimit(PlannerInfo *root)
{
  int limitVal = 0, offsetVal = 0;

  /* don't push down LIMIT if the query has a GROUP BY, DISTINCT, ORDER BY clause or aggregates
     or if the query refers to more than 1 table */
  if (root->parse->groupClause != NULL ||
  // NOTE: do not take sort clause into account here. Instead, we determ,ine in the planning phase
  // whether we can push down all sort fields and if so, we can safely push down the limit
  //  root->parse->sortClause != NULL ||
      root->parse->distinctClause != NULL ||
      root->parse->hasAggs ||
      root->parse->hasDistinctOn ||
      bms_num_members(root->all_baserels) != 1)
    return -1;

  /* only push down constant LIMITs that are not NULL */
  if (root->parse->limitCount != NULL && IsA(root->parse->limitCount, Const))
  {
    Const *limit = (Const *)root->parse->limitCount;
    if (limit->constisnull)
      return -1;
    limitVal = atoi(datumToString(limit->constvalue, limit->consttype));
  }
  else
  {
    return -1;
  }

  /* only consider OFFSETS that are non-NULL constants */
  if (root->parse->limitOffset != NULL && IsA(root->parse->limitOffset, Const))
  {
    Const *offset = (Const *)root->parse->limitOffset;
    if (!offset->constisnull)
      offsetVal = atoi(datumToString(offset->constvalue, offset->consttype));
  }

  return limitVal + offsetVal;
}

/*
 * fdwGetForeignPaths
 *		Create possible access paths for a scan on the foreign table.
 *		This is done by calling the "get_path_keys method on the python side,
 *		and parsing its result to build parameterized paths according to the
 *		equivalence classes found in the plan.
 */
static void fdwGetForeignPaths(PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid)
{
  List *paths; /* List of ForeignPath */
  ListCell *lc;
  FdwPathData *fdw_private;
  FdwPlanState *planstate = baserel->fdw_private;

  /* These lists are used to handle sort pushdown */
  List *apply_pathkeys = NULL;
  fdw_private = (FdwPathData *) palloc(sizeof(FdwPathData));
  fdw_private->deparsed_pathkeys =  NULL;
  // default canPushdownAllSortFields to true - this will be set to false
  fdw_private->canPushdownAllSortFields = true;

  /* Extract a friendly version of the pathkeys. */
  List *possiblePaths = goFdwGetPathKeys(planstate);

  /* Try to find parameterized paths */
  paths = findPaths(root, baserel, possiblePaths, planstate->startupCost, planstate, apply_pathkeys, fdw_private->deparsed_pathkeys);

  /* Handle sort pushdown */
  if (root->query_pathkeys)
  {
    List *deparsed;

    deparsed = deparse_sortgroup(root, foreigntableid, baserel);
    if (deparsed)
    {
      /* Update the sort_*_pathkeys lists if needed */
      fdw_private->canPushdownAllSortFields = computeDeparsedSortGroup(deparsed, planstate, &apply_pathkeys, &fdw_private->deparsed_pathkeys);
    } else {
        /* deparse_sortgroup failed returns empty list if no pathkeys for the PlannerInfo */
        fdw_private->canPushdownAllSortFields = true;
    }
  }

  /* Add a simple default path */
  paths = lappend(paths, create_foreignscan_path(
                             root,
                             baserel,
                             NULL, /* default pathtarget */
                             baserel->rows,
                             planstate->startupCost,
                             baserel->rows * baserel->reltarget->width * 100000, // table scan is very expensive
                             NIL,                                                /* no pathkeys */
                             NULL,
                             NULL,
                              (void *)fdw_private));

  /* Add each ForeignPath previously found */
  foreach (lc, paths)
  {
    ForeignPath *path = (ForeignPath *)lfirst(lc);
    /* Add the path without modification */
    add_path(baserel, (Path *)path);
    /* Add the path with sort pushdown if possible */
    if (apply_pathkeys && fdw_private->deparsed_pathkeys)
    {
      ForeignPath *newpath;
      newpath = create_foreignscan_path(
          root,
          baserel,
          NULL, /* default pathtarget */
          path->path.rows,
          path->path.startup_cost, path->path.total_cost,
          apply_pathkeys, NULL,
          NULL,
          (void *)fdw_private);
      newpath->path.param_info = path->path.param_info;
      add_path(baserel, (Path *)newpath);
    }
  }
}

/*
 * fdwGetForeignPlan
 *		Create a ForeignScan plan node for scanning the foreign table
 */
static ForeignScan *fdwGetForeignPlan(
    PlannerInfo *root,
    RelOptInfo *baserel,
    Oid foreigntableid,
    ForeignPath *best_path,
    List *tlist,
    List *scan_clauses,
    Plan *outer_plan)
{
  FdwPathData *pathdata = NULL;

  Index scan_relid = baserel->relid;
  FdwPlanState *planstate = (FdwPlanState *)baserel->fdw_private;
  best_path->path.pathtarget->width = planstate->width;
  scan_clauses = extract_actual_clauses(scan_clauses, false);

  if (best_path->fdw_private != NULL) {
    pathdata = (FdwPathData *)best_path->fdw_private;
    planstate->canPushdownAllSortFields = pathdata->canPushdownAllSortFields;
    planstate->pathkeys = pathdata->deparsed_pathkeys;
  }
  else {
    planstate->canPushdownAllSortFields = true;
    planstate->pathkeys = NULL;
  }

  ForeignScan *s = make_foreignscan(
      tlist,
      scan_clauses,
      scan_relid,
      scan_clauses, /* no expressions to evaluate */
      serializePlanState(planstate),
      NULL,
      NULL, /* All quals are meant to be rechecked */
      NULL);
  return s;
}

/*
 *	"Serialize" a FdwPlanState, so that it is safe to be carried
 *	between the plan and the execution safe.
 */
void *serializePlanState(FdwPlanState *state)
{
  List *result = NULL;
  // Serialize the number of attributes
  result = lappend(result, makeConst(INT4OID, -1, InvalidOid, 4, Int32GetDatum(state->numattrs), false, true));

  // Serialize the target list
  result = lappend(result, state->target_list);

  // Serialize the deparsed sort groups
  result = lappend(result, serializeDeparsedSortGroup(state->pathkeys));

  // Serialize the limit
  result = lappend(result, makeConst(INT4OID, -1, InvalidOid, 4, Int32GetDatum(state->limit), false, true));

  // Serialize the canPushdownAllSortFields boolean field
  result = lappend(result, makeConst(BOOLOID, -1, InvalidOid, 1, BoolGetDatum(state->canPushdownAllSortFields), false, true));

  return result;
}

/*
 *	"Deserialize" an internal state and inject it in an
 *	FdwExecState
 */
FdwExecState *initializeExecState(void *internalstate)
{
  FdwExecState *execstate = palloc0(sizeof(FdwExecState));
  // internalstate is actually a list generated by serializePlanState consisting of:
  //  numattrs, target_list, pathkeys, limit, canPushdownAllSortFields
  List *values = (List *)internalstate;
  AttrNumber numattrs = ((Const *)linitial(values))->constvalue;
  List *pathkeys;
  int limit;
  bool canPushdownAllSortFields;
  /* Those list must be copied, because their memory context can become */
  /* invalid during the execution (in particular with the cursor interface) */
  execstate->target_list = copyObject(lsecond(values));
  pathkeys = lthird(values);
  limit = ((Const *)lfourth(values))->constvalue;
  limit = ((Const *)lfourth(values))->constvalue;
  canPushdownAllSortFields = ((Const *)lfirst(list_tail(values)))->constvalue;

  execstate->pathkeys = deserializeDeparsedSortGroup(pathkeys);
  execstate->buffer = makeStringInfo();
  execstate->cinfos = palloc0(sizeof(ConversionInfo *) * numattrs);
  execstate->numattrs = numattrs;
  execstate->values = palloc(numattrs * sizeof(Datum));
  execstate->nulls = palloc(numattrs * sizeof(bool));
  execstate->limit = limit;
  execstate->canPushdownAllSortFields = canPushdownAllSortFields;
  return execstate;
}

/*
 * datumToString
 * 		Convert a Datum to a string by calling the type output function.
 * 		Returns the result or NULL if it cannot be converted.
 */
static char *datumToString(Datum datum, Oid type)
{
  StringInfoData result;
  regproc typoutput;
  HeapTuple tuple;
  char *str, *p;

  /* get the type's output function */
  tuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));
  if (!HeapTupleIsValid(tuple))
  {
    elog(ERROR, "cache lookup failed for type %u", type);
  }
  typoutput = ((Form_pg_type)GETSTRUCT(tuple))->typoutput;
  ReleaseSysCache(tuple);

  switch (type)
  {
  case TEXTOID:
  case CHAROID:
  case BPCHAROID:
  case VARCHAROID:
  case NAMEOID:
  case UUIDOID:
    str = DatumGetCString(OidFunctionCall1(typoutput, datum));

    if (str[0] == '\0')
      return NULL;

    /* strip "-" from "uuid" values */
    if (type == UUIDOID)
      convertUUID(str);

    /* quote string */
    initStringInfo(&result);
    appendStringInfo(&result, "'");
    for (p = str; *p; ++p)
    {
      if (*p == '\'')
        appendStringInfo(&result, "'");
      appendStringInfo(&result, "%c", *p);
    }
    appendStringInfo(&result, "'");
    break;
  case INT8OID:
  case INT2OID:
  case INT4OID:
  case OIDOID:
  case FLOAT4OID:
  case FLOAT8OID:
  case NUMERICOID:
    str = DatumGetCString(OidFunctionCall1(typoutput, datum));
    initStringInfo(&result);
    appendStringInfo(&result, "%s", str);
    break;
    //        case DATEOID:
    //			str = deparseDate(datum);
    //			initStringInfo(&result);
    //			appendStringInfo(&result, "(CAST ('%s' AS DATE))", str);
    //			break;
    //		case TIMESTAMPOID:
    //			str = deparseTimestamp(datum, false);
    //			initStringInfo(&result);
    //			appendStringInfo(&result, "(CAST ('%s' AS TIMESTAMP))", str);
    //			break;
    //		case TIMESTAMPTZOID:
    //			str = deparseTimestamp(datum, true);
    //			initStringInfo(&result);
    //			appendStringInfo(&result, "(CAST ('%s' AS TIMESTAMP WITH TIME ZONE))", str);
    //			break;
    //		case INTERVALOID:
    //			str = deparseInterval(datum);
    //			if (str == NULL)
    //				return NULL;
    //			initStringInfo(&result);
    //			appendStringInfo(&result, "%s", str);
    //			break;
  default:
    return NULL;
  }

  return result.data;
}
/*
 * convertUUID
 * 		Strip "-" from a PostgreSQL "uuid" so that Oracle can parse it.
 * 		In addition, convert the string to upper case.
 * 		This modifies the argument in place!
 */
char *convertUUID(char *uuid)
{
  char *p = uuid, *q = uuid, c;

  while (*p != '\0')
  {
    if (*p == '-')
      ++p;
    c = *(p++);
    if (c >= 'a' && c <= 'f')
      *(q++) = c - ('a' - 'A');
    else
      *(q++) = c;
  }
  *q = '\0';

  return uuid;
}
